#!/usr/bin/python
from subprocess import Popen, PIPE
from collections import defaultdict
from tempfile import mkstemp
from os import fdopen, unlink
from sys import exit

try:
    from entrypoint import entrywithfile, UsageError
except:
    raise
    print """
git clarity requires the Python entrypoint library, from pypi.
$ pip install entrypoint
    """.strip()
    exit()

def git(*args):
    """
        Call git with the arguments, and yield the stdout
    """
    proc = Popen(("git",) + args, stdout=PIPE)
    for line in proc.stdout:
        yield line
    # User will see git error message on stderr
    if proc.wait():
        exit()

@entrywithfile(output='w')
def main(no_merges=False, no_forks=False, all=False, format="pdf", output="-",*args):
    """
        git clarity creates clear graphviz graphs based on your repostiries history.

        By default all "named commits" (those which have a ref associated with
        them), all "fork commits" (those which have more than one child), all
        "merge commits" (those which hvae more than one parent), all "initial
        commits" (those with no parents) and all "last commits" (those with no
        children) are preserved. All other commits are deleted.

        The initial set of commits is generated from git log. Any positional
        arguments to git clarity will be passed on to git log (the default
        argument is --all).  If you want to pass flags to git log seperate them
        from the git clarity flags with --. Particularly --before, --after,
        --since, --until, --branches, --tags, --remotes and --skip, along with
        passing commit names may be useful. You should try and ensure that your
        git log command will produce reasonably contiguous portions of hitsory,
        or your graph will not have many edges.

        Still TODO: ignoring dull sections of graph (with lots of unnamed
        commits, but lots of branches and merges), and filtering for dull named
        commits.  Formatting (both graphviz options and node labels). Default
        output file on disk?

        args: Any arguments to be passed to git log when generating the tree.
             If you want to pass arguments begining with a hyphen, separate them with a --

        -M --no-merges: Don't include commits just because they are merges.
        -F --no-forks:  Don't include commits just because they are forks.
        -a --all: Include all commits (cannot be used with any --no-* option)
        -T --format: The output format (default: pdf), raw can be used to get the input to graphviz,
                     for other valid options consult `dot -T?`
        -o --output: Put the output to a file (default: -, stdout)
    """

    if (no_merges or no_forks) and all:
        raise UsageError("It doesn't make sense to ask for --all with --no-merges or --no-forks")

    parents = defaultdict(set)
    children = defaultdict(set)
    refnames = {}
    interesting = set()

    # Read entire graph
    if not args:
        args = ("--all",)

    args = args + ("--format=format:%H|%P|%d",)

    for line in git("log", *args):

        child, commits, desc = line.strip().split("|")

        # Make "named commits" interesting
        if desc:
            refnames[child] = desc
            interesting.add(child)

        if commits:
            for parent in commits.split(" "):
                parents[child].add(parent)
                children[parent].add(child)

    # Make "initial commits" interesting
    for parent in children.keys():
        if not parents[parent]:
            interesting.add(parent)

    # Make "trailing commits" interesting
    for child in parents.keys():
        if not children[child]:
            interesting.add(child)

    # Delete everything that isn't interesting
    if not all:
        size = 0
        while size != len(parents) + len(children):
            size = len(parents) + len(children)

            for commit in parents.keys():
                if ((no_merges or len(parents[commit]) == 1) and
                        (no_forks or len(children[commit]) == 1) and
                            (commit not in interesting)):

                    for parent in parents[commit]:
                        for child in children[commit]:
                            children[parent].discard(commit)
                            children[parent].add(child)
                            parents[child].discard(commit)
                            parents[child].add(parent)

                    del parents[commit], children[commit]

    # Extract list of edges from graph
    edges = []
    for child in parents:
        for parent in parents[child]:
            edges.append([parent, child])

    # Format as graphviz input.
    name = lambda commit: refnames[commit] if commit in refnames else commit[0:10]

    result = ["digraph G {"]
    result += [('"%s" -> "%s"' % tuple(map(name,edge))) for edge in edges]
    result += ["}",""]
    result = "\n".join(result)

    # Output
    if format == "raw":
        output.write(result)
    else:
        Popen(["dot", "-T" + format], stdin=PIPE, stdout=output).communicate(result)
